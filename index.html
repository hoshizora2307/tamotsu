<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Sato Tamotsu Shooting - Robust Ver</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; color: white; font-family: 'Arial Black', sans-serif; }
        canvas { display: block; background: #333; margin: 20px auto; border: 5px solid #ffd700; }
        .info { text-align: center; }
        #score { font-size: 2em; color: #ff4500; }
    </style>
</head>
<body>
    <div class="info">
        <h1>佐藤 保：スキンヘッド・リベンジ</h1>
        <p>移動: 矢印キー / 攻撃: スペースキー</p>
        <div id="score">SCORE: 0</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');

canvas.width = 900;
canvas.height = 500;

// --- 画像の準備 ---
const satoImg = new Image();
let isImageLoaded = false;
satoImg.src = 'tamotsu.png'; // 画像ファイル名をチェック！

satoImg.onload = () => {
    isImageLoaded = true;
    console.log("画像読み込み成功");
};

satoImg.onerror = () => {
    console.error("画像が見つかりません: tamotsu.png をHTMLと同じフォルダに置いてください。");
};

// --- ゲーム設定 ---
let score = 0;
let gameOver = false;
const keys = {};

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const sato = {
    x: 50,
    y: 200,
    width: 80,
    height: 100,
    speed: 7,
    draw() {
        if (isImageLoaded) {
            ctx.drawImage(satoImg, this.x, this.y, this.width, this.height);
        } else {
            // 画像がない時の代わりの「佐藤 保（肉色の四角）」
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#fff';
            ctx.fillText("画像なし", this.x + 10, this.y + 30);
        }
    }
};

let bullets = [];
let enemies = [];

function spawnEnemy() {
    if (gameOver) return;
    enemies.push({
        x: canvas.width,
        y: Math.random() * (canvas.height - 40),
        width: 40,
        height: 40,
        speed: 4 + (score / 200)
    });
    setTimeout(spawnEnemy, Math.max(300, 1000 - score / 5));
}

function update() {
    if (gameOver) return;

    if (keys['ArrowUp'] && sato.y > 0) sato.y -= sato.speed;
    if (keys['ArrowDown'] && sato.y < canvas.height - sato.height) sato.y += sato.speed;
    
    if (keys['Space']) {
        if (bullets.length === 0 || bullets[bullets.length-1].x < sato.x + 150) {
            bullets.push({ x: sato.x + sato.width, y: sato.y + sato.height/3, speed: 12 });
        }
    }

    bullets.forEach((b, i) => {
        b.x += b.speed;
        if (b.x > canvas.width) bullets.splice(i, 1);
    });

    enemies.forEach((en, i) => {
        en.x -= en.speed;
        
        // 当たり判定
        if (en.x < sato.x + sato.width * 0.7 && en.x + en.width > sato.x + sato.width * 0.3 &&
            en.y < sato.y + sato.height * 0.7 && en.y + en.height > sato.y + sato.height * 0.3) {
            gameOver = true;
            alert("佐藤 保、散る！ スコア: " + score);
            location.reload();
        }

        bullets.forEach((b, bi) => {
            if (b.x < en.x + en.width && b.x + 20 > en.x &&
                b.y < en.y + en.height && b.y + 10 > en.y) {
                enemies.splice(i, 1);
                bullets.splice(bi, 1);
                score += 10;
                scoreElement.innerText = `SCORE: ${score}`;
            }
        });

        if (en.x < -50) enemies.splice(i, 1);
    });
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    sato.draw();

    // 弾
    ctx.fillStyle = '#ffff00';
    bullets.forEach(b => ctx.fillRect(b.x, b.y, 20, 5));

    // 敵
    ctx.fillStyle = '#ff4d4d';
    enemies.forEach(en => ctx.fillRect(en.x, en.y, en.width, en.height));

    requestAnimationFrame(gameLoop);
}

// ループ関数を分離
function gameLoop() {
    update();
    draw();
}

// 即座に開始！
spawnEnemy();
gameLoop();
</script>
</body>
</html>
